

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mammoth.utils.optimizers &mdash; MAMMOTH  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
        <script src="https://unpkg.com/mermaid@8.4.8/dist/mermaid.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> MAMMOTH
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../main.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ref.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">Frequently Asked Questions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ.html">About MAMMOTH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ.html#mammoth-and-opennmt">MAMMOTH and OpenNMT</a></li>
</ul>
<p class="caption"><span class="caption-text">MAMMOTH features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modular_model.html">Modular Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config_config.html">Config-config tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../attention_bridges.html">Attention Bridge</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../prepare_data.html">Prepare Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Translation.html">Translation</a></li>
</ul>
<p class="caption"><span class="caption-text">Scripts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../options/build_vocab.html">Build Vocab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../options/train.html">Train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../options/translate.html">Translate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../options/server.html">Server</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mammoth.html">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mammoth.modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mammoth.translation.html">Translation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mammoth.translate.translation_server.html">Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mammoth.inputters.html">Data Loaders</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MAMMOTH</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mammoth.utils.optimizers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mammoth.utils.optimizers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Optimizers class &quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">mammoth.utils.misc</span> <span class="kn">import</span> <span class="n">fn_args</span>
<span class="kn">from</span> <span class="nn">torch.nn.utils</span> <span class="kn">import</span> <span class="n">clip_grad_norm_</span>


<span class="k">def</span> <span class="nf">attention_bridge_optimizer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">task_queue_manager</span><span class="p">,</span> <span class="n">base_optimizer</span><span class="p">):</span>
    <span class="n">suboptimizers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">my_grouped_components</span> <span class="o">=</span> <span class="n">task_queue_manager</span><span class="o">.</span><span class="n">get_grouped_components</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">component_type</span> <span class="ow">in</span> <span class="n">my_grouped_components</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">my_grouped_components</span><span class="p">[</span><span class="n">component_type</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">component_type</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">component_type</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">component_id</span><span class="p">])</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;adapter&#39;</span> <span class="ow">in</span> <span class="n">param_name</span> <span class="ow">and</span> <span class="s1">&#39;adapter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component_type</span><span class="p">:</span>
                    <span class="c1"># omit adapters from base component optimizers</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;embedding&#39;</span> <span class="ow">in</span> <span class="n">param_name</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;adding </span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1"> to suboptimizer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">suboptimizers</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Trying to create second optimizer for &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="n">optimizer</span> <span class="o">=</span> <span class="n">base_optimizer</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">suboptimizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimizer</span>

    <span class="k">for</span> <span class="n">generator_id</span> <span class="ow">in</span> <span class="n">task_queue_manager</span><span class="o">.</span><span class="n">get_generators</span><span class="p">():</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;generator_</span><span class="si">{</span><span class="n">generator_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">generator</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">base_optimizer</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">suboptimizers</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;generator_</span><span class="si">{</span><span class="n">generator_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimizer</span>

    <span class="n">attParam</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">attention_bridge</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">attParam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

    <span class="c1"># skip AB optimizer if AB is not in use</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attParam</span><span class="p">):</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">base_optimizer</span><span class="p">(</span><span class="n">attParam</span><span class="p">)</span>
        <span class="n">suboptimizers</span><span class="p">[</span><span class="s2">&quot;attention_bridge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimizer</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">MultipleOptimizer</span><span class="p">(</span><span class="n">suboptimizers</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">optimizer</span>


<span class="k">def</span> <span class="nf">build_torch_optimizer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">task_queue_manager</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds the PyTorch optimizer.</span>

<span class="sd">    We use the default parameters for Adam that are suggested by</span>
<span class="sd">    the original paper https://arxiv.org/pdf/1412.6980.pdf</span>
<span class="sd">    These values are also used by other established implementations,</span>
<span class="sd">    e.g. https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer</span>
<span class="sd">    https://keras.io/optimizers/</span>
<span class="sd">    Recently there are slightly different values used in the paper</span>
<span class="sd">    &quot;Attention is all you need&quot;</span>
<span class="sd">    https://arxiv.org/pdf/1706.03762.pdf, particularly the value beta2=0.98</span>
<span class="sd">    was used there however, beta2=0.999 is still arguably the more</span>
<span class="sd">    established value, so we use that here as well</span>

<span class="sd">    Args:</span>
<span class="sd">      model: The model to optimize.</span>
<span class="sd">      opts. The dictionary of options.</span>

<span class="sd">    Returns:</span>
<span class="sd">      A ``torch.optim.Optimizer`` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">]</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="p">[</span><span class="n">opts</span><span class="o">.</span><span class="n">adam_beta1</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">adam_beta2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;sgd&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;adagrad&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adagrad</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">initial_accumulator_value</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">adagrad_accumulator_init</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;adadelta&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adadelta</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;adafactor&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">attention_bridge_optimizer</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">task_queue_manager</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="n">AdaFactorFairSeq</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">weight_decay</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;adam&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">attention_bridge_optimizer</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">task_queue_manager</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="n">betas</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">weight_decay</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;adamw&#39;</span><span class="p">:</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">attention_bridge_optimizer</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">task_queue_manager</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="n">betas</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">weight_decay</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s1">&#39;fusedadam&#39;</span><span class="p">:</span>
        <span class="c1"># we use here a FusedAdam() copy of an old Apex repo</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">FusedAdam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="n">betas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">model_dtype</span> <span class="o">==</span> <span class="s1">&#39;fp16&#39;</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">apex</span>

            <span class="c1"># In this case use the old FusedAdam with FP16_optimizer wrapper</span>
            <span class="n">static_loss_scale</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">loss_scale</span>
            <span class="n">dynamic_loss_scale</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">loss_scale</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">optimizer</span> <span class="o">=</span> <span class="n">apex</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">FP16_Optimizer</span><span class="p">(</span>
                <span class="n">optimizer</span><span class="p">,</span> <span class="n">static_loss_scale</span><span class="o">=</span><span class="n">static_loss_scale</span><span class="p">,</span> <span class="n">dynamic_loss_scale</span><span class="o">=</span><span class="n">dynamic_loss_scale</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid optimizer type: &#39;</span> <span class="o">+</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimizer</span>


<span class="k">def</span> <span class="nf">make_learning_rate_decay_fn</span><span class="p">(</span><span class="n">opts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the learning decay function from options.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">decay_method</span> <span class="o">==</span> <span class="s1">&#39;noam&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">noam_decay</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">warmup_steps</span><span class="p">,</span> <span class="n">model_dim</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">model_dim</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">decay_method</span> <span class="o">==</span> <span class="s1">&#39;noamwd&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">noamwd_decay</span><span class="p">,</span>
            <span class="n">warmup_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">warmup_steps</span><span class="p">,</span>
            <span class="n">model_dim</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">model_dim</span><span class="p">,</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate_decay</span><span class="p">,</span>
            <span class="n">decay_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">decay_steps</span><span class="p">,</span>
            <span class="n">start_step</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">start_decay_steps</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">decay_method</span> <span class="o">==</span> <span class="s1">&#39;rsqrt&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">rsqrt_decay</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">warmup_steps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">decay_method</span> <span class="o">==</span> <span class="s1">&#39;linear_warmup&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">linear_warmup_decay</span><span class="p">,</span>
            <span class="n">warmup_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">warmup_steps</span><span class="p">,</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">train_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">train_steps</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">start_decay_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">exponential_decay</span><span class="p">,</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">learning_rate_decay</span><span class="p">,</span>
            <span class="n">decay_steps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">decay_steps</span><span class="p">,</span>
            <span class="n">start_step</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">start_decay_steps</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">noam_decay</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="p">,</span> <span class="n">model_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Learning rate schedule described in</span>
<span class="sd">    https://arxiv.org/pdf/1706.03762.pdf.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">model_dim</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">step</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">step</span> <span class="o">*</span> <span class="n">warmup_steps</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">noamwd_decay</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="p">,</span> <span class="n">model_dim</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">decay_steps</span><span class="p">,</span> <span class="n">start_step</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Learning rate schedule optimized for huge batches&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">model_dim</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">step</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">step</span> <span class="o">*</span> <span class="n">warmup_steps</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">))</span>
        <span class="o">*</span> <span class="n">rate</span> <span class="o">**</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="n">start_step</span> <span class="o">+</span> <span class="n">decay_steps</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">//</span> <span class="n">decay_steps</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">exponential_decay</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">decay_steps</span><span class="p">,</span> <span class="n">start_step</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A standard exponential decay, scaling the learning rate by :obj:`rate`</span>
<span class="sd">    every :obj:`decay_steps` steps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">rate</span> <span class="o">**</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="n">start_step</span> <span class="o">+</span> <span class="n">decay_steps</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">//</span> <span class="n">decay_steps</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rsqrt_decay</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decay based on the reciprocal of the step square root.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">linear_warmup_decay</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">train_steps</span><span class="p">):</span>
    <span class="n">end_rate</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">rate</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="n">warmup_steps</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">step</span> <span class="o">/</span> <span class="n">warmup_steps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_rate</span><span class="p">,</span> <span class="p">(</span><span class="n">train_steps</span> <span class="o">-</span> <span class="n">step</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">train_steps</span> <span class="o">-</span> <span class="n">warmup_steps</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">MultipleOptimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement multiple optimizers&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">multiOptims_Langs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiOptims_Langs</span> <span class="o">=</span> <span class="n">multiOptims_Langs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">param_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">:</span>
            <span class="n">optimizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">param_groups</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">param_groups</span>

    <span class="k">def</span> <span class="nf">zero_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the gradient of all sub-optimizers to zero&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad_scaler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Step through all the suboptimizers&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_any_param_has_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_any_param_has_grad</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;has_grad&#39;</span><span class="p">):</span>
                    <span class="c1"># if there are parameters not tracked by the hook,</span>
                    <span class="c1"># then always perform the step</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;At least one parameter in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> did not have the hook&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">has_grad</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">report_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_steps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Optimizer &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; has been stepped </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1"> times&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="Optimizer"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer">[docs]</a><span class="k">class</span> <span class="nc">Optimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Controller class for optimization. Mostly a thin</span>
<span class="sd">    wrapper for `optim`, but also useful for implementing</span>
<span class="sd">    rate scheduling beyond what is currently available.</span>
<span class="sd">    Also implements necessary methods for training RNNs such</span>
<span class="sd">    as grad manipulations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">learning_rate_decay_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_grad_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the controller.</span>

<span class="sd">        Args:</span>
<span class="sd">          optimizer: A ``torch.optim.Optimizer`` instance.</span>
<span class="sd">          learning_rate: The initial learning rate.</span>
<span class="sd">          learning_rate_decay_fn: An optional callable taking the current step</span>
<span class="sd">            as argument and return a learning rate scaling factor.</span>
<span class="sd">          max_grad_norm: Clip gradients to this global norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate_decay_fn</span> <span class="o">=</span> <span class="n">learning_rate_decay_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_grad_norm</span> <span class="o">=</span> <span class="n">max_grad_norm</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaler</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Optimizer.from_opts"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer.from_opts">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_opts</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">task_queue_manager</span><span class="p">,</span> <span class="n">checkpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds the optimizer from options.</span>

<span class="sd">        Args:</span>
<span class="sd">          cls: The ``Optimizer`` class to instantiate.</span>
<span class="sd">          model: The model to optimize.</span>
<span class="sd">          opts: The dict of user options.</span>
<span class="sd">          checkpoint: An optional checkpoint to load states from.</span>

<span class="sd">        Returns:</span>
<span class="sd">          An ``Optimizer`` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optim_opt</span> <span class="o">=</span> <span class="n">opts</span>
        <span class="n">optim_state_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">train_from</span> <span class="ow">and</span> <span class="n">checkpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;optim&#39;</span><span class="p">]</span>
            <span class="n">ckpt_opt</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;opts&#39;</span><span class="p">]</span>
            <span class="n">ckpt_state_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optim</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">):</span>  <span class="c1"># Backward compatibility.</span>
                <span class="n">ckpt_state_dict</span><span class="p">[</span><span class="s1">&#39;training_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">_step</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">ckpt_state_dict</span><span class="p">[</span><span class="s1">&#39;decay_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">_step</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">ckpt_state_dict</span><span class="p">[</span><span class="s1">&#39;optimizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ckpt_state_dict</span> <span class="o">=</span> <span class="n">optim</span>

            <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">reset_optim</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="c1"># Load everything from the checkpoint.</span>
                <span class="n">optim_opt</span> <span class="o">=</span> <span class="n">ckpt_opt</span>
                <span class="n">optim_state_dict</span> <span class="o">=</span> <span class="n">ckpt_state_dict</span>
            <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">reset_optim</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="c1"># Build everything from scratch.</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">reset_optim</span> <span class="o">==</span> <span class="s1">&#39;states&#39;</span><span class="p">:</span>
                <span class="c1"># Reset optimizer, keep options.</span>
                <span class="n">optim_opt</span> <span class="o">=</span> <span class="n">ckpt_opt</span>
                <span class="n">optim_state_dict</span> <span class="o">=</span> <span class="n">ckpt_state_dict</span>
                <span class="k">del</span> <span class="n">optim_state_dict</span><span class="p">[</span><span class="s1">&#39;optimizer&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">opts</span><span class="o">.</span><span class="n">reset_optim</span> <span class="o">==</span> <span class="s1">&#39;keep_states&#39;</span><span class="p">:</span>
                <span class="c1"># Reset options, keep optimizer.</span>
                <span class="n">optim_state_dict</span> <span class="o">=</span> <span class="n">ckpt_state_dict</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">build_torch_optimizer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optim_opt</span><span class="p">,</span> <span class="n">task_queue_manager</span><span class="p">),</span>
            <span class="n">optim_opt</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">learning_rate_decay_fn</span><span class="o">=</span><span class="n">make_learning_rate_decay_fn</span><span class="p">(</span><span class="n">optim_opt</span><span class="p">),</span>
            <span class="n">max_grad_norm</span><span class="o">=</span><span class="n">optim_opt</span><span class="o">.</span><span class="n">max_grad_norm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">model_dtype</span> <span class="o">==</span> <span class="s2">&quot;fp16&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">optim</span> <span class="o">==</span> <span class="s2">&quot;fusedadam&quot;</span><span class="p">:</span>
                <span class="n">optimizer</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">=</span> <span class="s2">&quot;legacy&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optimizer</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">=</span> <span class="s2">&quot;amp&quot;</span>
                <span class="kn">from</span> <span class="nn">torch.cuda.amp</span> <span class="kn">import</span> <span class="n">GradScaler</span>

                <span class="n">optimizer</span><span class="o">.</span><span class="n">_scaler</span> <span class="o">=</span> <span class="n">GradScaler</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">optim_state_dict</span><span class="p">:</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">optim_state_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optimizer</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The current training step.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_step</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if use torch amp mix precision training.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">==</span> <span class="s2">&quot;amp&quot;</span>

<div class="viewcode-block" id="Optimizer.learning_rate"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer.learning_rate">[docs]</a>    <span class="k">def</span> <span class="nf">learning_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current learning rate.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate_decay_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate_decay_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decay_step</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_rate</span></div>

    <span class="k">def</span> <span class="nf">state_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;training_step&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_step</span><span class="p">,</span>
            <span class="s1">&#39;decay_step&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_step</span><span class="p">,</span>
            <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">load_state_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_step</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s1">&#39;training_step&#39;</span><span class="p">]</span>
        <span class="c1"># State can be partially restored.</span>
        <span class="k">if</span> <span class="s1">&#39;decay_step&#39;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decay_step</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="s1">&#39;decay_step&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;optimizer&#39;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s1">&#39;optimizer&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="Optimizer.zero_grad"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer.zero_grad">[docs]</a>    <span class="k">def</span> <span class="nf">zero_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Zero the gradients of optimized parameters.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span></div>

<div class="viewcode-block" id="Optimizer.backward"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer.backward">[docs]</a>    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper for backward pass. Some optimizer requires ownership of the</span>
<span class="sd">        backward pass.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaler</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">==</span> <span class="s2">&quot;legacy&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s2">&quot;update_master_grads&quot;</span> <span class="ow">in</span> <span class="n">fn_args</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">backward</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;update_master_grads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span></div>

<div class="viewcode-block" id="Optimizer.step"><a class="viewcode-back" href="../../../mammoth.html#mammoth.utils.Optimizer.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the model parameters based on current gradients.</span>

<span class="sd">        Optionally, will employ gradient modification or update learning</span>
<span class="sd">        rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">suboptimizer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaler</span><span class="o">.</span><span class="n">unscale_</span><span class="p">(</span><span class="n">suboptimizer</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">==</span> <span class="s2">&quot;legacy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="p">,</span> <span class="s2">&quot;update_master_grads&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">update_master_grads</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="p">,</span> <span class="s2">&quot;clip_master_grads&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_grad_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">clip_master_grads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_grad_norm</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
            <span class="n">group</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">learning_rate</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_grad_norm</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp16</span> <span class="o">!=</span> <span class="s2">&quot;legacy&quot;</span><span class="p">:</span>
                <span class="n">clip_grad_norm_</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_grad_norm</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="p">)</span>

            <span class="c1"># Updates the scale for next iteration.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaler</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_step</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_step</span> <span class="o">+=</span> <span class="mi">1</span></div></div>


<span class="c1"># Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf</span>
<span class="c1"># inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">class AdaFactor(torch.optim.Optimizer):</span>

<span class="sd">    def __init__(self, params, lr=None, beta1=0.9, beta2=0.999, eps1=1e-30,</span>
<span class="sd">                 eps2=1e-3, cliping_threshold=1, non_constant_decay=True,</span>
<span class="sd">                 enable_factorization=True, ams_grad=True, weight_decay=0):</span>

<span class="sd">        enable_momentum = beta1 != 0</span>

<span class="sd">        if non_constant_decay:</span>
<span class="sd">            ams_grad = False</span>

<span class="sd">        defaults = dict(lr=lr, beta1=beta1, beta2=beta2, eps1=eps1,</span>
<span class="sd">                        eps2=eps2, cliping_threshold=cliping_threshold,</span>
<span class="sd">                        weight_decay=weight_decay, ams_grad=ams_grad,</span>
<span class="sd">                        enable_factorization=enable_factorization,</span>
<span class="sd">                        enable_momentum=enable_momentum,</span>
<span class="sd">                        non_constant_decay=non_constant_decay)</span>

<span class="sd">        super(AdaFactor, self).__init__(params, defaults)</span>

<span class="sd">    def __setstate__(self, state):</span>
<span class="sd">        super(AdaFactor, self).__setstate__(state)</span>

<span class="sd">    def _experimental_reshape(self, shape):</span>
<span class="sd">        temp_shape = shape[2:]</span>
<span class="sd">        if len(temp_shape) == 1:</span>
<span class="sd">            new_shape = (shape[0], shape[1]*shape[2])</span>
<span class="sd">        else:</span>
<span class="sd">            tmp_div = len(temp_shape) // 2 + len(temp_shape) % 2</span>
<span class="sd">            new_shape = (shape[0]*functools.reduce(operator.mul,</span>
<span class="sd">                                                   temp_shape[tmp_div:], 1),</span>
<span class="sd">                         shape[1]*functools.reduce(operator.mul,</span>
<span class="sd">                                                   temp_shape[:tmp_div], 1))</span>
<span class="sd">        return new_shape, copy(shape)</span>

<span class="sd">    def _check_shape(self, shape):</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        output1 - True - algorithm for matrix, False - vector;</span>
<span class="sd">        output2 - need reshape</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        if len(shape) &gt; 2:</span>
<span class="sd">            return True, True</span>
<span class="sd">        elif len(shape) == 2:</span>
<span class="sd">            return True, False</span>
<span class="sd">        elif len(shape) == 2 and (shape[0] == 1 or shape[1] == 1):</span>
<span class="sd">            return False, False</span>
<span class="sd">        else:</span>
<span class="sd">            return False, False</span>

<span class="sd">    def _rms(self, x):</span>
<span class="sd">        return sqrt(torch.mean(x.pow(2)))</span>

<span class="sd">    def step(self, closure=None):</span>
<span class="sd">        loss = None</span>
<span class="sd">        if closure is not None:</span>
<span class="sd">            loss = closure()</span>
<span class="sd">        for group in self.param_groups:</span>
<span class="sd">            for p in group[&#39;params&#39;]:</span>
<span class="sd">                if p.grad is None:</span>
<span class="sd">                    continue</span>
<span class="sd">                grad = p.grad.data</span>

<span class="sd">                if grad.is_sparse:</span>
<span class="sd">                    raise RuntimeError(&#39;Adam does not support sparse \</span>
<span class="sd">                                       gradients, use SparseAdam instead&#39;)</span>

<span class="sd">                is_matrix, is_need_reshape = self._check_shape(grad.size())</span>
<span class="sd">                new_shape = p.data.size()</span>
<span class="sd">                if is_need_reshape and group[&#39;enable_factorization&#39;]:</span>
<span class="sd">                    new_shape, old_shape = \</span>
<span class="sd">                        self._experimental_reshape(p.data.size())</span>
<span class="sd">                    grad = grad.view(new_shape)</span>

<span class="sd">                state = self.state[p]</span>
<span class="sd">                if len(state) == 0:</span>
<span class="sd">                    state[&#39;step&#39;] = 0</span>
<span class="sd">                    if group[&#39;enable_momentum&#39;]:</span>
<span class="sd">                        state[&#39;exp_avg&#39;] = torch.zeros(new_shape,</span>
<span class="sd">                                                       dtype=torch.float32,</span>
<span class="sd">                                                       device=p.grad.device)</span>

<span class="sd">                    if is_matrix and group[&#39;enable_factorization&#39;]:</span>
<span class="sd">                        state[&#39;exp_avg_sq_R&#39;] = \</span>
<span class="sd">                            torch.zeros((1, new_shape[1]),</span>
<span class="sd">                                        dtype=torch.float32,</span>
<span class="sd">                                        device=p.grad.device)</span>
<span class="sd">                        state[&#39;exp_avg_sq_C&#39;] = \</span>
<span class="sd">                            torch.zeros((new_shape[0], 1),</span>
<span class="sd">                                        dtype=torch.float32,</span>
<span class="sd">                                        device=p.grad.device)</span>
<span class="sd">                    else:</span>
<span class="sd">                        state[&#39;exp_avg_sq&#39;] = torch.zeros(new_shape,</span>
<span class="sd">                                                          dtype=torch.float32,</span>
<span class="sd">                                                          device=p.grad.device)</span>
<span class="sd">                    if group[&#39;ams_grad&#39;]:</span>
<span class="sd">                        state[&#39;exp_avg_sq_hat&#39;] = \</span>
<span class="sd">                            torch.zeros(new_shape, dtype=torch.float32,</span>
<span class="sd">                                        device=p.grad.device)</span>

<span class="sd">                if group[&#39;enable_momentum&#39;]:</span>
<span class="sd">                    exp_avg = state[&#39;exp_avg&#39;]</span>

<span class="sd">                if is_matrix and group[&#39;enable_factorization&#39;]:</span>
<span class="sd">                    exp_avg_sq_r = state[&#39;exp_avg_sq_R&#39;]</span>
<span class="sd">                    exp_avg_sq_c = state[&#39;exp_avg_sq_C&#39;]</span>
<span class="sd">                else:</span>
<span class="sd">                    exp_avg_sq = state[&#39;exp_avg_sq&#39;]</span>

<span class="sd">                if group[&#39;ams_grad&#39;]:</span>
<span class="sd">                    exp_avg_sq_hat = state[&#39;exp_avg_sq_hat&#39;]</span>

<span class="sd">                state[&#39;step&#39;] += 1</span>
<span class="sd">                lr_t = group[&#39;lr&#39;]</span>
<span class="sd">                lr_t *= max(group[&#39;eps2&#39;], self._rms(p.data))</span>

<span class="sd">                if group[&#39;enable_momentum&#39;]:</span>
<span class="sd">                    if group[&#39;non_constant_decay&#39;]:</span>
<span class="sd">                        beta1_t = group[&#39;beta1&#39;] * \</span>
<span class="sd">                                  (1 - group[&#39;beta1&#39;] ** (state[&#39;step&#39;] - 1)) \</span>
<span class="sd">                                  / (1 - group[&#39;beta1&#39;] ** state[&#39;step&#39;])</span>
<span class="sd">                    else:</span>
<span class="sd">                        beta1_t = group[&#39;beta1&#39;]</span>
<span class="sd">                    exp_avg.mul_(beta1_t).add_(1 - beta1_t, grad)</span>

<span class="sd">                if group[&#39;non_constant_decay&#39;]:</span>
<span class="sd">                    beta2_t = group[&#39;beta2&#39;] * \</span>
<span class="sd">                              (1 - group[&#39;beta2&#39;] ** (state[&#39;step&#39;] - 1)) / \</span>
<span class="sd">                              (1 - group[&#39;beta2&#39;] ** state[&#39;step&#39;])</span>
<span class="sd">                else:</span>
<span class="sd">                    beta2_t = group[&#39;beta2&#39;]</span>

<span class="sd">                if is_matrix and group[&#39;enable_factorization&#39;]:</span>
<span class="sd">                    exp_avg_sq_r.mul_(beta2_t). \</span>
<span class="sd">                        add_(1 - beta2_t, torch.sum(torch.mul(grad, grad).</span>
<span class="sd">                                                    add_(group[&#39;eps1&#39;]),</span>
<span class="sd">                                                    dim=0, keepdim=True))</span>
<span class="sd">                    exp_avg_sq_c.mul_(beta2_t). \</span>
<span class="sd">                        add_(1 - beta2_t, torch.sum(torch.mul(grad, grad).</span>
<span class="sd">                                                    add_(group[&#39;eps1&#39;]),</span>
<span class="sd">                                                    dim=1, keepdim=True))</span>
<span class="sd">                    v = torch.mul(exp_avg_sq_c,</span>
<span class="sd">                                  exp_avg_sq_r).div_(torch.sum(exp_avg_sq_r))</span>
<span class="sd">                else:</span>
<span class="sd">                    exp_avg_sq.mul_(beta2_t). \</span>
<span class="sd">                        addcmul_(1 - beta2_t, grad, grad). \</span>
<span class="sd">                        add_((1 - beta2_t)*group[&#39;eps1&#39;])</span>
<span class="sd">                    v = exp_avg_sq</span>

<span class="sd">                g = grad</span>
<span class="sd">                if group[&#39;enable_momentum&#39;]:</span>
<span class="sd">                    g = torch.div(exp_avg, 1 - beta1_t ** state[&#39;step&#39;])</span>

<span class="sd">                if group[&#39;ams_grad&#39;]:</span>
<span class="sd">                    torch.max(exp_avg_sq_hat, v, out=exp_avg_sq_hat)</span>
<span class="sd">                    v = exp_avg_sq_hat</span>
<span class="sd">                    u = torch.div(g, (torch.div(v, 1 - beta2_t **</span>
<span class="sd">                                  state[&#39;step&#39;])).sqrt().add_(group[&#39;eps1&#39;]))</span>
<span class="sd">                else:</span>
<span class="sd">                    u = torch.div(g, v.sqrt())</span>

<span class="sd">                u.div_(max(1, self._rms(u) / group[&#39;cliping_threshold&#39;]))</span>
<span class="sd">                p.data.add_(-lr_t * (u.view(old_shape) if is_need_reshape and</span>
<span class="sd">                            group[&#39;enable_factorization&#39;] else u))</span>

<span class="sd">                if group[&#39;weight_decay&#39;] != 0:</span>
<span class="sd">                    p.data.add_(-group[&#39;weight_decay&#39;] * lr_t, p.data)</span>

<span class="sd">        return loss</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FusedAdam</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements Adam algorithm. Currently GPU-only.</span>
<span class="sd">       Requires Apex to be installed via</span>
<span class="sd">    ``python setup.py install --cuda_ext --cpp_ext``.</span>
<span class="sd">    It has been proposed in `Adam: A Method for Stochastic Optimization`_.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        params (iterable): iterable of parameters to optimize or dicts defining</span>
<span class="sd">            parameter groups.</span>
<span class="sd">        lr (float, optional): learning rate. (default: 1e-3)</span>
<span class="sd">        betas (Tuple[float, float], optional): coefficients used for computing</span>
<span class="sd">            running averages of gradient and its square.</span>
<span class="sd">            (default: (0.9, 0.999))</span>
<span class="sd">        eps (float, optional): term added to the denominator to improve</span>
<span class="sd">            numerical stability. (default: 1e-8)</span>
<span class="sd">        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)</span>
<span class="sd">        amsgrad (boolean, optional): whether to use the AMSGrad variant of this</span>
<span class="sd">            algorithm from the paper `On the Convergence of Adam and Beyond`_</span>
<span class="sd">            (default: False) NOT SUPPORTED in FusedAdam!</span>
<span class="sd">        eps_inside_sqrt (boolean, optional): in the &#39;update parameters&#39; step,</span>
<span class="sd">            adds eps to the bias-corrected second moment estimate before</span>
<span class="sd">            evaluating square root instead of adding it to the square root of</span>
<span class="sd">            second moment estimate as in the original paper. (default: False)</span>
<span class="sd">    .. _Adam: A Method for Stochastic Optimization:</span>
<span class="sd">        https://arxiv.org/abs/1412.6980</span>
<span class="sd">    .. _On the Convergence of Adam and Beyond:</span>
<span class="sd">        https://openreview.net/forum?id=ryQu7f-RZ</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
        <span class="n">bias_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">betas</span><span class="o">=</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">),</span>
        <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">eps_inside_sqrt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weight_decay</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">max_grad_norm</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">amsgrad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">global</span> <span class="n">fused_adam_cuda</span>
        <span class="n">fused_adam_cuda</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;fused_adam_cuda&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">amsgrad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;AMSGrad variant not supported.&#39;</span><span class="p">)</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span>
            <span class="n">bias_correction</span><span class="o">=</span><span class="n">bias_correction</span><span class="p">,</span>
            <span class="n">betas</span><span class="o">=</span><span class="n">betas</span><span class="p">,</span>
            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">weight_decay</span><span class="o">=</span><span class="n">weight_decay</span><span class="p">,</span>
            <span class="n">max_grad_norm</span><span class="o">=</span><span class="n">max_grad_norm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FusedAdam</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_mode</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">eps_inside_sqrt</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">grad_norms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a single optimization step.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            closure (callable, optional): A closure that reevaluates the model</span>
<span class="sd">                and returns the loss.</span>
<span class="sd">            grads (list of tensors, optional): weight gradient to use for the</span>
<span class="sd">                optimizer update. If gradients have type torch.half, parameters</span>
<span class="sd">                are expected to be in type torch.float. (default: None)</span>
<span class="sd">            output params (list of tensors, optional): A reduced precision copy</span>
<span class="sd">                of the updated weights written out in addition to the regular</span>
<span class="sd">                updated weights. Have to be of same type as gradients.</span>
<span class="sd">                (default: None)</span>
<span class="sd">            scale (float, optional): factor to divide gradient tensor values</span>
<span class="sd">                by before applying to weights. (default: 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">closure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">closure</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">grads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grads_group</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_groups</span><span class="p">)</span>
        <span class="c1"># backward compatibility</span>
        <span class="c1"># assuming a list/generator of parameter means single group</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="n">grads_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">grads</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">grads</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">grads_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">grads</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grads_group</span> <span class="o">=</span> <span class="n">grads</span>

        <span class="k">if</span> <span class="n">output_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_params_group</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_groups</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_params</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="n">output_params_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_params</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">output_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">output_params_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_params</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_params_group</span> <span class="o">=</span> <span class="n">output_params</span>

        <span class="k">if</span> <span class="n">grad_norms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grad_norms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_groups</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">grads_this_group</span><span class="p">,</span> <span class="n">output_params_this_group</span><span class="p">,</span> <span class="n">grad_norm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_groups</span><span class="p">,</span> <span class="n">grads_group</span><span class="p">,</span> <span class="n">output_params_group</span><span class="p">,</span> <span class="n">grad_norms</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">grads_this_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grads_this_group</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">output_params_this_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_params_this_group</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">])</span>

            <span class="c1"># compute combined scale factor for this group</span>
            <span class="n">combined_scale</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;max_grad_norm&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># norm is in fact norm*scale</span>
                <span class="n">clip</span> <span class="o">=</span> <span class="p">((</span><span class="n">grad_norm</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;max_grad_norm&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clip</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">combined_scale</span> <span class="o">=</span> <span class="n">clip</span> <span class="o">*</span> <span class="n">scale</span>

            <span class="n">bias_correction</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;bias_correction&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">output_param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">],</span> <span class="n">grads_this_group</span><span class="p">,</span> <span class="n">output_params_this_group</span><span class="p">):</span>
                <span class="c1"># note: p.grad should not ever be set for correct operation of</span>
                <span class="c1"># mixed precision optimizer that sometimes sends None gradients</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">grad</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span>
                <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;sparse gradient not supported&#39;</span><span class="p">)</span>

                <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

                <span class="c1"># State initialization</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">state</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># Exponential moving average of gradient values</span>
                    <span class="n">state</span><span class="p">[</span><span class="s1">&#39;exp_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="c1"># Exponential moving average of squared gradient values</span>
                    <span class="n">state</span><span class="p">[</span><span class="s1">&#39;exp_avg_sq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="n">exp_avg</span><span class="p">,</span> <span class="n">exp_avg_sq</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;exp_avg&#39;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;exp_avg_sq&#39;</span><span class="p">]</span>
                <span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;betas&#39;</span><span class="p">]</span>

                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">out_p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">output_param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_param</span>
                <span class="n">fused_adam_cuda</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">out_p</span><span class="p">,</span>
                    <span class="n">exp_avg</span><span class="p">,</span>
                    <span class="n">exp_avg_sq</span><span class="p">,</span>
                    <span class="n">grad</span><span class="p">,</span>
                    <span class="n">group</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">],</span>
                    <span class="n">beta1</span><span class="p">,</span>
                    <span class="n">beta2</span><span class="p">,</span>
                    <span class="n">group</span><span class="p">[</span><span class="s1">&#39;eps&#39;</span><span class="p">],</span>
                    <span class="n">combined_scale</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eps_mode</span><span class="p">,</span>
                    <span class="n">bias_correction</span><span class="p">,</span>
                    <span class="n">group</span><span class="p">[</span><span class="s1">&#39;weight_decay&#39;</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>


<span class="k">class</span> <span class="nc">AdaFactorFairSeq</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements Adafactor algorithm.</span>

<span class="sd">    This implementation is based on:</span>
<span class="sd">    `Adafactor: Adaptive Learning Rates with Sublinear Memory Cost`</span>
<span class="sd">    (see https://arxiv.org/abs/1804.04235)</span>

<span class="sd">    Note that this optimizer internally adjusts the learning rate</span>
<span class="sd">    depending on the *scale_parameter*, *relative_step* and</span>
<span class="sd">    *warmup_init* options. To use a manual (external) learning rate</span>
<span class="sd">    schedule you should set `scale_parameter=False` and</span>
<span class="sd">    `relative_step=False`.</span>

<span class="sd">    Args:</span>
<span class="sd">        params (iterable): iterable of parameters to optimize or dicts defining</span>
<span class="sd">            parameter groups</span>
<span class="sd">        lr (float, optional): external learning rate (default: None)</span>
<span class="sd">        eps (tuple[float, float]): regularization constans for square gradient</span>
<span class="sd">            and parameter scale respectively (default: (1e-30, 1e-3))</span>
<span class="sd">        clip_threshold (float): threshold of root mean square of</span>
<span class="sd">            final gradient update (default: 1.0)</span>
<span class="sd">        decay_rate (float): coefficient used to compute running averages of square</span>
<span class="sd">            gradient (default: -0.8)</span>
<span class="sd">        beta1 (float): coefficient used for computing running averages of gradient</span>
<span class="sd">            (default: None)</span>
<span class="sd">        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)</span>
<span class="sd">        scale_parameter (bool): if True, learning rate is scaled by root mean square of</span>
<span class="sd">            parameter (default: True)</span>
<span class="sd">        relative_step (bool): if True, time-dependent learning rate is computed</span>
<span class="sd">            instead of external learning rate (default: True)</span>
<span class="sd">        warmup_init (bool): time-dependent learning rate computation depends on</span>
<span class="sd">            whether warm-up initialization is being used (default: False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">lr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-30</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">),</span>
        <span class="n">clip_threshold</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">decay_rate</span><span class="o">=-</span><span class="mf">0.8</span><span class="p">,</span>
        <span class="n">beta1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weight_decay</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">scale_parameter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">relative_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">warmup_init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">lr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">relative_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot combine manual lr and relative_step options&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">warmup_init</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">relative_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;warmup_init requires relative_step=True&quot;</span><span class="p">)</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span>
            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">clip_threshold</span><span class="o">=</span><span class="n">clip_threshold</span><span class="p">,</span>
            <span class="n">decay_rate</span><span class="o">=</span><span class="n">decay_rate</span><span class="p">,</span>
            <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span>
            <span class="n">weight_decay</span><span class="o">=</span><span class="n">weight_decay</span><span class="p">,</span>
            <span class="n">scale_parameter</span><span class="o">=</span><span class="n">scale_parameter</span><span class="p">,</span>
            <span class="n">relative_step</span><span class="o">=</span><span class="n">relative_step</span><span class="p">,</span>
            <span class="n">warmup_init</span><span class="o">=</span><span class="n">warmup_init</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AdaFactorFairSeq</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">supports_memory_efficient_fp16</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">supports_flat_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_group</span><span class="p">,</span> <span class="n">param_state</span><span class="p">):</span>
        <span class="n">rel_step_sz</span> <span class="o">=</span> <span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;relative_step&quot;</span><span class="p">]:</span>
            <span class="n">min_step</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">param_state</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;warmup_init&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="mf">1e-2</span>
            <span class="n">rel_step_sz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_step</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">param_state</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]))</span>
        <span class="n">param_scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;scale_parameter&quot;</span><span class="p">]:</span>
            <span class="n">param_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;eps&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">param_state</span><span class="p">[</span><span class="s2">&quot;RMS&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">param_scale</span> <span class="o">*</span> <span class="n">rel_step_sz</span>

    <span class="k">def</span> <span class="nf">_get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_group</span><span class="p">,</span> <span class="n">param_shape</span><span class="p">):</span>
        <span class="n">factored</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="n">use_first_moment</span> <span class="o">=</span> <span class="n">param_group</span><span class="p">[</span><span class="s2">&quot;beta1&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">factored</span><span class="p">,</span> <span class="n">use_first_moment</span>

    <span class="k">def</span> <span class="nf">_rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_approx_sq_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp_avg_sq_row</span><span class="p">,</span> <span class="n">exp_avg_sq_col</span><span class="p">):</span>
        <span class="n">r_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp_avg_sq_row</span> <span class="o">/</span> <span class="n">exp_avg_sq_row</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">rsqrt_</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c_factor</span> <span class="o">=</span> <span class="n">exp_avg_sq_col</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">rsqrt</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">r_factor</span><span class="p">,</span> <span class="n">c_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a single optimization step.</span>

<span class="sd">        Args:</span>
<span class="sd">            closure (callable, optional): A closure that reevaluates the model</span>
<span class="sd">                and returns the loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">closure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">closure</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span>
                <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">}:</span>
                    <span class="n">grad</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Adafactor does not support sparse gradients.&quot;</span><span class="p">)</span>

                <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="n">grad_shape</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">shape</span>

                <span class="n">factored</span><span class="p">,</span> <span class="n">use_first_moment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_options</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">grad_shape</span><span class="p">)</span>
                <span class="c1"># State Initialization</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">state</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">use_first_moment</span><span class="p">:</span>
                        <span class="c1"># Exponential moving average of gradient values</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">factored</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_row&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grad_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grad_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

                    <span class="n">state</span><span class="p">[</span><span class="s2">&quot;RMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">use_first_moment</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">factored</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_row&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_row&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_col&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

                <span class="n">p_data_fp32</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">}:</span>
                    <span class="n">p_data_fp32</span> <span class="o">=</span> <span class="n">p_data_fp32</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;RMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rms</span><span class="p">(</span><span class="n">p_data_fp32</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

                <span class="n">beta2t</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">],</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;decay_rate&quot;</span><span class="p">])</span>
                <span class="n">update</span> <span class="o">=</span> <span class="p">(</span><span class="n">grad</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;eps&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">factored</span><span class="p">:</span>
                    <span class="n">exp_avg_sq_row</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_row&quot;</span><span class="p">]</span>
                    <span class="n">exp_avg_sq_col</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq_col&quot;</span><span class="p">]</span>

                    <span class="n">exp_avg_sq_row</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">beta2t</span><span class="p">)</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="n">update</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">beta2t</span><span class="p">)</span>
                    <span class="n">exp_avg_sq_col</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">beta2t</span><span class="p">)</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="n">update</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">beta2t</span><span class="p">)</span>

                    <span class="c1"># Approximation of exponential moving average of square of gradient</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_sq_grad</span><span class="p">(</span><span class="n">exp_avg_sq_row</span><span class="p">,</span> <span class="n">exp_avg_sq_col</span><span class="p">)</span>
                    <span class="n">update</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exp_avg_sq</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg_sq&quot;</span><span class="p">]</span>

                    <span class="n">exp_avg_sq</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">beta2t</span><span class="p">)</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">beta2t</span><span class="p">)</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">exp_avg_sq</span><span class="o">.</span><span class="n">rsqrt</span><span class="p">()</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

                <span class="n">update</span><span class="o">.</span><span class="n">div_</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_rms</span><span class="p">(</span><span class="n">update</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;clip_threshold&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">1.0</span><span class="p">))</span>
                <span class="n">update</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">use_first_moment</span><span class="p">:</span>
                    <span class="n">exp_avg</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;exp_avg&quot;</span><span class="p">]</span>
                    <span class="n">exp_avg</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;beta1&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;beta1&quot;</span><span class="p">])</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">exp_avg</span>

                <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;weight_decay&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">p_data_fp32</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="n">p_data_fp32</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;weight_decay&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">])</span>

                <span class="n">p_data_fp32</span><span class="o">.</span><span class="n">add_</span><span class="p">(</span><span class="o">-</span><span class="n">update</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">}:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">p_data_fp32</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loss</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2023, HelsinkiNLP

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>